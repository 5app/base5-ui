(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{QKAw:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return s})),a.d(t,"default",(function(){return b}));var n=a("Fcif"),o=a("+I+c"),i=(a("mXGw"),a("/FXl")),r=a("TjRS"),c=a("ZFoC"),l=a("Pnyn"),s=(a("aD51"),{});void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/useBackLink/README.mdx"}});var h={_frontmatter:s},p=r.a;function b(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(i.b)(p,Object(n.a)({},h,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"usebacklink"},"useBackLink"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useBackLink"),' is a hook that returns a link to the previous page that the user has visited (if available). It can track the user\'s history across multiple hierarchy levels to avoid circular navigation issues, and allows navigating "up" a page level instead of only "back" to the last page viewed.'),Object(i.b)("h2",{id:"the-problem"},"The problem"),Object(i.b)("p",null,'Hard-coding back links in an app where pages may have different entry points can quickly lead to a bad user experience. Users expect a link or button labelled "Back" to take them back to the page they came from, or to a parent page. Clicking "Back" only to be taken to an unexpected or irrelevant page can be frustrating.'),Object(i.b)("p",null,"It might be tempting to just mirror the browser's back button behaviour using ",Object(i.b)("inlineCode",{parentName:"p"},"history.back")," to create back buttons on your site. However, this comes with several downsides:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"It doesn't work when there's no browser history, for example after opening a new browser window. If your user clicked a link in an email to arrive on an article page with a button wired up to ",Object(i.b)("inlineCode",{parentName:"p"},"history.back"),", that button would simply do nothing. Of course it would be much better if it took them to an article overview page or another fallback location instead.")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},'Conflicts with manual navigation. A user may navigate back on your site by clicking a regular link, which will be registered by the browser as "forward navigation". This means that a new history entry will be created even though the user has navigated backwards relative to your page\'s hierarchy or structure.')),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Circular navigation: While users expect their ",Object(i.b)("em",{parentName:"p"},"browser")," to take them back exactly where they were when they click the browser's back button, they don't necessarily expect back links on your site to work the same way, instead they might map them to the site's hierarchy instead. Imagine navigating from the homepage of a web shop to a category page. On the category page, you click on a product, then return to the category page. If that category page had a \"Back\" button, where would you expect it to take you? Back to the product you just viewed, or back to the homepage? I'd suspect that most users would expect to be taken back to the homepage (i.e. higher up in the site hierarchy), yet ",Object(i.b)("inlineCode",{parentName:"p"},"history.back")," would simply take them back to the product."),Object(i.b)("p",{parentName:"li"},"Of course the back link on the category page could be hard-coded to always point to the homepage, but what if categories could be navigated to from various other pages in the shop?"))),Object(i.b)("h2",{id:"the-solution"},"The solution"),Object(i.b)("p",null,"The base5-ui ",Object(i.b)("inlineCode",{parentName:"p"},"useBackLink")," hook and ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider"),' component were built to handle this sort of complexity in a maintainable way. They allow you to assign "levels" to your routes to correctly keep track of the user\'s browsing history through the hierarchy of your page.'),Object(i.b)("p",null,"Sticking with our previous example, the shop's homepage and all its siblings would be assigned a level of ",Object(i.b)("inlineCode",{parentName:"p"},"0"),", the category page a level of ",Object(i.b)("inlineCode",{parentName:"p"},"1"),", and the product pages a level of ",Object(i.b)("inlineCode",{parentName:"p"},"2"),"."),Object(i.b)("p",null,"The following section will describe what the set up for this would look like:"),Object(i.b)("h2",{id:"walkthrough-and-examples"},"Walkthrough and examples"),Object(i.b)("p",null,"To enable the most basic usage of the hook, you need to wrap your app with the ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," component like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import {useLocation, Link} from 'react-router';\nimport {BackLinkProvider} from 'base5-ui/useBackLink';\n\nfunction YourApp({children}) {\n    const {pathname} = useLocation();\n    return (\n        <BackLinkProvider location={pathname} track={[pathname]}>\n            {children}\n        </BackLinkProvider>\n    );\n}\n\nfunction BackLink({fallbackLink, children}) {\n    const backLink = useBackLink();\n    return <Link to={backLink || fallbackLink}>{children}</Link>;\n}\n")),Object(i.b)("p",null,"Pass the location object or the current path to the ",Object(i.b)("inlineCode",{parentName:"p"},"location")," prop of the ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," component, and pass the same property to the ",Object(i.b)("inlineCode",{parentName:"p"},"track")," prop, making sure that it is wrapped in an array."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"track")," prop of the ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," component works similarly to the dependency array of React's ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect")," hook. Whenever any variable in the array changes, ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," will update its history. This means you don't have to rely solely on the pathname for tracking back link changes, but you can also include query parameters or any other variable you want to track."),Object(i.b)("p",null,"The example below shows how the two query parameters ",Object(i.b)("inlineCode",{parentName:"p"},"modal")," and ",Object(i.b)("inlineCode",{parentName:"p"},"page")," are now also taken into account for creating new entries in the history, even if ",Object(i.b)("inlineCode",{parentName:"p"},"pathname")," stays unchanged."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const location = useLocation();\nconst {pathname, search} = location;\nconst {modal, page} = parseQuery(search);\n\nreturn (\n    <BackLinkProvider location={location} track={[pathname, modal, page]}>\n        {children}\n    </BackLinkProvider>\n);\n")),Object(i.b)("p",null,"Now that ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," knows when to update its history, it'll keep track of the user's navigation in a linear fashion. It doesn't work the same as the browser's history, though: To avoid the circular navigation issues mentioned earlier, our history doesn't allow duplicate entries. So as soon as the user navigates to a page that already exists in the history, the existing page will be made the new user location, and any later history entries will be discarded."),Object(i.b)("p",null,"If we want to take our site's hierarchy into account, we also need to pass it a function that, given the current location, will return that location's hierarchy level. This function should be passed to the ",Object(i.b)("inlineCode",{parentName:"p"},"getLocationLevel")," prop as shown below. (Note the use of the ",Object(i.b)("inlineCode",{parentName:"p"},"matchPath")," helper from react-router, which helps us to find out which route we're on.)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import {matchPath} from 'react-router';\n\nreturn (\n    <BackLinkProvider\n        location={location}\n        track={[pathname, modal, page]}\n        getLocationLevel={({pathname}) => {\n            if (matchPath(pathname, {path: '/product/:id'})) {\n                return 2;\n            } else if (matchPath(pathname, {path: '/category/:id'})) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }}\n    >\n        {children}\n    </BackLinkProvider>\n);\n")),Object(i.b)("p",null,"Now, the ",Object(i.b)("inlineCode",{parentName:"p"},"backLink")," returned from the ",Object(i.b)("inlineCode",{parentName:"p"},"useBackLink")," hook will return the previously visited page of the current hierarchy level â€“ if there is one. If there's no previous page on the current level, it'll point to the last page of the ",Object(i.b)("em",{parentName:"p"},"previous")," hierarchy level."),Object(i.b)("p",null,"When using the hook, you can also choose to ",Object(i.b)("em",{parentName:"p"},"always")," go back up one hierarchy level. This is useful to avoid the circular navigation issue described earlier, for example on overview pages that have local navigation (think tabs or a side bar with links). Make sure that all sibling pages report the same hierarchy, and a back link wired up as shown below will always point to the last page viewed on the nearest hierarchy level, ignoring any local navigation that has taken place."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"function BackLink({fallback, children}) {\n    const backLink = useBackLink({up: true});\n    return <Link to={backLink || fallback}>{children}</Link>;\n}\n")),Object(i.b)("h2",{id:"handling-automatic-redirects"},"Handling automatic redirects"),Object(i.b)("p",null,"If a user is automatically redirected from one URL to another, two entries will be created in the back link history. This is a problem: If the user navigates back to the first entry, the redirect will be re-triggered, and the user ends up back on the page they just tried to navigate away from!"),Object(i.b)("p",null,"Luckily, there's a way to tell ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," to treat redirects as a single link: Make sure that the page you've redirected the user to knows that it's a \"redirect target\". You can do this by adding a query parameter like ",Object(i.b)("inlineCode",{parentName:"p"},"&wasRedirected=true")," to its URL, or by adding some React Router location state. Then you can pass that information to the ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," using the ",Object(i.b)("inlineCode",{parentName:"p"},"wasRedirected")," prop, and your back links will work again."),Object(i.b)("p",null,"Note that the location passed to ",Object(i.b)("inlineCode",{parentName:"p"},"BackLinkProvider")," ",Object(i.b)("strong",{parentName:"p"},"must not")," include the 'wasRedirected' hint, as otherwise we'd get the same issue in reverse."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"<BackLinkProvider\n    wasRedirected={location.state?.wasRedirected}\n    location={{\n        ...location\n        state: {\n            ...location.state,\n            wasRedirected: undefined,\n        }\n    }}\n    track={[pathname, modal, page]}\n    getLocationLevel={getLocationLevel}\n>\n    {children}\n</BackLinkProvider>\n")),Object(i.b)("h2",{id:"backlinkprovider-props"},"BackLinkProvider props"),Object(i.b)(c.d,{isToggle:!0,of:l.a,mdxType:"Props"}))}void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!b.hasOwnProperty("__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/useBackLink/README.mdx"}}),b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-use-back-link-readme-mdx-ff634b98e8f5eeff9159.js.map