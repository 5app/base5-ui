{"version":3,"sources":["webpack:///../src/useBackLink/README.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isToggle","of","BackLinkProvider","isMDXComponent"],"mappings":"gRAQaA,G,UAAe,S,4MAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,iBAAQ,CACN,GAAM,eADR,eAGA,qBAAG,0BAAYC,WAAW,KAAvB,eAAH,gSACA,iBAAQ,CACN,GAAM,eADR,eAGA,0VACA,sGAAqF,0BAAYA,WAAW,KAAvB,gBAArF,qFACA,sBACE,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,mMAAuN,0BAAYA,WAAW,KAAvB,gBAAvN,+JAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,2TAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,iDAAqE,kBAAIA,WAAW,KAAf,WAArE,ioBAAwuB,0BAAYA,WAAW,KAAvB,gBAAxuB,gDACA,iBAAGA,WAAW,MAAd,0LAGJ,iBAAQ,CACN,GAAM,gBADR,gBAGA,qCAAoB,0BAAYA,WAAW,KAAvB,eAApB,aAAyF,0BAAYA,WAAW,KAAvB,oBAAzF,+NACA,kIAAiH,0BAAYA,WAAW,KAAvB,KAAjH,kCAAiM,0BAAYA,WAAW,KAAvB,KAAjM,sCAAqR,0BAAYA,WAAW,KAAvB,KAArR,KACA,sGACA,iBAAQ,CACN,GAAM,4BADR,4BAGA,uGAAsF,0BAAYA,WAAW,KAAvB,oBAAtF,yBACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,oeAmBL,4EAA2D,0BAAYA,WAAW,KAAvB,YAA3D,gBAAgI,0BAAYA,WAAW,KAAvB,oBAAhI,iDAA8O,0BAAYA,WAAW,KAAvB,SAA9O,sDACA,4BAAW,0BAAYA,WAAW,KAAvB,SAAX,gBAA6E,0BAAYA,WAAW,KAAvB,oBAA7E,iEAA2M,0BAAYA,WAAW,KAAvB,aAA3M,sDAAuT,0BAAYA,WAAW,KAAvB,oBAAvT,yMACA,6EAA4D,0BAAYA,WAAW,KAAvB,SAA5D,QAAsH,0BAAYA,WAAW,KAAvB,QAAtH,qFAA4P,0BAAYA,WAAW,KAAvB,YAA5P,qBACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,gQAYL,iCAAgB,0BAAYA,WAAW,KAAvB,oBAAhB,8bACA,sOAAqN,0BAAYA,WAAW,KAAvB,oBAArN,8CAAgU,0BAAYA,WAAW,KAAvB,aAAhU,gFACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,sgBAsBL,iCAAgB,0BAAYA,WAAW,KAAvB,YAAhB,sBAA2F,0BAAYA,WAAW,KAAvB,eAA3F,yLAA4U,kBAAIA,WAAW,KAAf,YAA5U,qBACA,oEAAmD,kBAAIA,WAAW,KAAf,UAAnD,+aACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,iKAOL,iBAAQ,CACN,GAAM,0BADR,0BAGA,YAAC,IAAD,CAAOC,UAAQ,EAACC,GAAIC,IAAkBJ,QAAQ,gB,0MAKlDH,EAAWQ,gBAAiB","file":"component---src-use-back-link-readme-mdx-f26e1d053bb8a1108676.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/circleci/repo/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { Props } from 'docz';\nimport BackLinkProvider from './BackLinkProvider';\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h1 {...{\n      \"id\": \"usebacklink\"\n    }}>{`useBackLink`}</h1>\n    <p><inlineCode parentName=\"p\">{`useBackLink`}</inlineCode>{` is a hook that returns a link to the previous page that the user has visited (if available). It can track the user's history across multiple hierarchy levels to avoid circular navigation issues, and allows navigating \"up\" a page level instead of only \"back\" to the last page viewed.`}</p>\n    <h2 {...{\n      \"id\": \"the-problem\"\n    }}>{`The problem`}</h2>\n    <p>{`Hard-coding back links in an app where pages may have different entry points can quickly lead to a bad user experience. Users expect a link or button labelled \"Back\" to take them back to the page they came from, or to a parent page. Clicking \"Back\" only to be taken to an unexpected or irrelevant page can be frustrating.`}</p>\n    <p>{`It might be tempting to just mirror the browser's back button behaviour using `}<inlineCode parentName=\"p\">{`history.back`}</inlineCode>{` to create back buttons on your site. However, this comes with several downsides:`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`It doesn't work when there's no browser history, for example after opening a new browser window. If your user clicked a link in an email to arrive on an article page with a button wired up to `}<inlineCode parentName=\"p\">{`history.back`}</inlineCode>{`, that button would simply do nothing. Of course it would be much better if it took them to an article overview page or another fallback location instead.`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Conflicts with manual navigation. A user may navigate back on your site by clicking a regular link, which will be registered by the browser as \"forward navigation\". This means that a new history entry will be created even though the user has navigated backwards relative to your page's hierarchy or structure.`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Circular navigation: While users expect their `}<em parentName=\"p\">{`browser`}</em>{` to take them back exactly where they were when they click the browser's back button, they don't necessarily expect back links on your site to work the same way, instead they might map them to the site's hierarchy instead. Imagine navigating from the homepage of a web shop to a category page. On the category page, you click on a product, then return to the category page. If that category page had a \"Back\" button, where would you expect it to take you? Back to the product you just viewed, or back to the homepage? I'd suspect that most users would expect to be taken back to the homepage (i.e. higher up in the site hierarchy), yet `}<inlineCode parentName=\"p\">{`history.back`}</inlineCode>{` would simply take them back to the product.`}</p>\n        <p parentName=\"li\">{`Of course the back link on the category page could be hard-coded to always point to the homepage, but what if categories could be navigated to from various other pages in the shop?`}</p>\n      </li>\n    </ol>\n    <h2 {...{\n      \"id\": \"the-solution\"\n    }}>{`The solution`}</h2>\n    <p>{`The base5-ui `}<inlineCode parentName=\"p\">{`useBackLink`}</inlineCode>{` hook and `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` component were built to handle this sort of complexity in a maintainable way. They allow you to assign \"levels\" to your routes to correctly keep track of the user's browsing history through the hierarchy of your page.`}</p>\n    <p>{`Sticking with our previous example, the shop's homepage and all its siblings would be assigned a level of `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{`, the category page a level of `}<inlineCode parentName=\"p\">{`1`}</inlineCode>{`, and the product pages a level of `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{`.`}</p>\n    <p>{`The following section will describe what the set up for this would look like:`}</p>\n    <h2 {...{\n      \"id\": \"walkthrough-and-examples\"\n    }}>{`Walkthrough and examples`}</h2>\n    <p>{`To enable the most basic usage of the hook, you need to wrap your app with the `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` component like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import {useLocation, Link} from 'react-router';\nimport {BackLinkProvider} from 'base5-ui/useBackLink';\n\nfunction YourApp({children}) {\n    const {pathname} = useLocation();\n    return (\n        <BackLinkProvider location={pathname} track={[pathname]}>\n            {children}\n        </BackLinkProvider>\n    );\n}\n\nfunction BackLink({fallbackLink, children}) {\n    const backLink = useBackLink();\n    return <Link to={backLink || fallbackLink}>{children}</Link>;\n}\n`}</code></pre>\n    <p>{`Pass the location object or the current path to the `}<inlineCode parentName=\"p\">{`location`}</inlineCode>{` prop of the `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` component, and pass the same property to the `}<inlineCode parentName=\"p\">{`track`}</inlineCode>{` prop, making sure that it is wrapped in an array.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`track`}</inlineCode>{` prop of the `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` component works similarly to the dependency array of React's `}<inlineCode parentName=\"p\">{`useEffect`}</inlineCode>{` hook. Whenever any variable in the array changes, `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` will update its history. This means you don't have to rely solely on the pathname for tracking back link changes, but you can also include query parameters or any other variable you want to track.`}</p>\n    <p>{`The example below shows how the two query parameters `}<inlineCode parentName=\"p\">{`modal`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`page`}</inlineCode>{` are now also taken into account for creating new entries in the history, even if `}<inlineCode parentName=\"p\">{`pathname`}</inlineCode>{` stays unchanged.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const location = useLocation();\nconst {pathname, search} = location;\nconst {modal, page} = parseQuery(search);\n\nreturn (\n    <BackLinkProvider location={location} track={[pathname, modal, page]}>\n        {children}\n    </BackLinkProvider>\n);\n`}</code></pre>\n    <p>{`Now that `}<inlineCode parentName=\"p\">{`BackLinkProvider`}</inlineCode>{` knows when to update its history, it'll keep track of the user's navigation in a linear fashion. It doesn't work the same as the browser's history, though: To avoid the circular navigation issues mentioned earlier, our history doesn't allow duplicate entries. So as soon as the user navigates to a page that already exists in the history, the existing page will be made the new user location, and any later history entries will be discarded.`}</p>\n    <p>{`If we want to take our site's hierarchy into account, we also need to pass it a function that, given the current location, will return that location's hierarchy level. This function should be passed to the `}<inlineCode parentName=\"p\">{`getLocationLevel`}</inlineCode>{` prop as shown below. (Note the use of the `}<inlineCode parentName=\"p\">{`matchPath`}</inlineCode>{` helper from react-router, which helps us to find out which route we're on.)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import {matchPath} from 'react-router';\n\nreturn (\n    <BackLinkProvider\n        location={location}\n        track={[pathname, modal, page]}\n        getLocationLevel={({pathname}) => {\n            if (matchPath(pathname, {path: '/product/:id'})) {\n                return 2;\n            } else if (matchPath(pathname, {path: '/category/:id'})) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }}\n    >\n        {children}\n    </BackLinkProvider>\n);\n`}</code></pre>\n    <p>{`Now, the `}<inlineCode parentName=\"p\">{`backLink`}</inlineCode>{` returned from the `}<inlineCode parentName=\"p\">{`useBackLink`}</inlineCode>{` hook will return the previously visited page of the current hierarchy level â€“ if there is one. If there's no previous page on the current level, it'll point to the last page of the `}<em parentName=\"p\">{`previous`}</em>{` hierarchy level.`}</p>\n    <p>{`When using the hook, you can also choose to `}<em parentName=\"p\">{`always`}</em>{` go back up one hierarchy level. This is useful to avoid the circular navigation issue described earlier, for example on overview pages that have local navigation (think tabs or a side bar with links). Make sure that all sibling pages report the same hierarchy, and a back link wired up as shown below will always point to the last page viewed on the nearest hierarchy level, ignoring any local navigation that has taken place.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function BackLink({fallback, children}) {\n    const backLink = useBackLink({up: true});\n    return <Link to={backLink || fallback}>{children}</Link>;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"backlinkprovider-props\"\n    }}>{`BackLinkProvider props`}</h2>\n    <Props isToggle of={BackLinkProvider} mdxType=\"Props\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}